function Y=clean_ksvd(TextPath,D)
% This function receives the path of an image with missing pixels
% and reconstructs it using the dictionary matrix D generated by the K-SVD method. This function
% should be used after the "ksvd" function, which generates the matrix D.
%
% For more information, refer to the Toolbox manual.
%
% Syntax: Y=clean_ksvd('TextPath',D)
%
% Input parameters:
% TextPath: Path of the image to be reconstructed.
% D: Dictionary matrix generated by the K-SVD method.
% Output parameter:
% Y: Matrix representing the reconstructed image.
 
    I=imread(TextPath);
    [m_org, n_org]=size(I);
    Z=im2double(block_img_8(I));
    
    [m_z,n_z]=size(Z);
    mBlock=m_z/8; nBlock=n_z/8;
    
    VecBlock=im2block8(Z);
    
    t=10; iter=0;
    blockImg=[];
    for i=1:mBlock
        Aux=[];
        for j=1:nBlock
            iter=iter+1;
            y=VecBlock(:,iter);
            D_d=decim_mat(D,y);
            x = OMP(y,D_d,t);
            Aux=[Aux reshape(D*x,[8,8])];
        end
        blockImg=[blockImg; Aux];
    end
    
    Y=im2uint8(imresize(blockImg,[m_org,n_org]));
end


function Y=im2block8(X)
% This function converts a matrix X of size m x n into a matrix Y of
% size 64 x mn/64, where each column of Y comes from a vectorized block
% of size 8 x 8 from X.
    
    [m,n]=size(X);
    b1=m/8; b2=n/8;
    Y=[];
    for i=1:b1
        for j=1:b2
            Aux=X((i-1)*8+1:i*8,(j-1)*8+1:j*8);
            Y=[Y Aux(:)];
        end
    end
end




function x=OMP(y,A,k)
    %"Orthogonal Matching Pursuit" Algorithm 
    [~,n]=size(A); r=y; T=[];    
    x=zeros(n,1);
    for i=1:k
       g=A'*r;
       t=argmax_OMP(g,A);   
       T=sort([T t]);       
       A_T=mtx_colt(T,A);   
       xaux=pinv(A_T)*y;    
       for j=1:length(T)
           x(T(j))=xaux(j); 
       end
       r=y-A*x;             
    end    
end

% Auxiliary Functions of the OMP Algorithm

function t=argmax_OMP(g,A)
    x=[]; n=size(A,2);    
    for j=1:n
       z=abs(g(j))/(norm(A(:,j)));
       x_n=[x z];
       x=x_n;
    end    
    [~, t] = max(x);    
end

function B=mtx_colt(T,A)
    m=size(A,1);
    n1=length(T);
    B=zeros(m,n1);
    for i=1:n1
        B(:,i)=A(:,T(i));
    end
end

function D=decim_mat(D0,y)
    n=length(y); D=D0; m=size(D0,2);
    for i=1:n
        if y(i)==0
            D(i,:)=zeros(1,m);
        end
    end
end

function Y=block_img_8(X)
 
    % This function returns an image, where the number of rows and columns
    % is divisible by 8. The dimensions of the new image Y are the
    % multiples of 8 closest to the dimensions of the original image X.
    %
    % Function Structure: Y=block_img_8(X)
    %
    % Input parameter:
    %           X = an image of size m x n
    % Output parameter:
    %           Y = an image of size m1 x n1, where m1 and
    %               n1 are divisible by 8, and abs(m1-m) and 
    %               abs(n1-n) are minimum.
    
    
    [m,n]=size(X);
    s1=mod(m,8);
    s2=mod(n,8);
    if and(s1==0,s2==0)
        m1=m; n1=n;
    elseif and(s1==0,s2~=0)
        if s2<=4
            m1=m; n1=n-s2;
        else
            m1=m; n1=n+8-s2;
        end        
    elseif and(s1~=0,s2==0)
        if s1<=4
            m1=m-s1; n1=n;
        else
            m1=m+8-s1; n1=n;
        end
    elseif and(s1~=0,s2~=0)
        if s1<=4
            m1=m-s1;
        else
            m1=m+8-s1;
        end
        if s2<=4
            n1=n-s2;
        else
            n1=n+8-s2;
        end        
    end       
    Y=imresize(X,[m1,n1]);
end

